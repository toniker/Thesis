\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}pragma once}

\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}CAN/ApplicationLayer.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}CAN/Frame.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}Task.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}queue.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}Peripheral\PYGZus{}Definitions.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}ifdef OBC\PYGZus{}EQM\PYGZus{}LCL}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}LCLDefinitions.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}endif}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * Contains functionality of a Gatekeeper Task for the CAN Bus. It has the sole access to CAN, to avoid any}
\PYG{c+cm}{ * deadlocks that might be caused by simultaneous requests of access to the same resource. It works by having anyone}
\PYG{c+cm}{ * needing to access CAN, send the data in a queue. Then this task receives queue elements and sends them via CAN.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * @example @code}
\PYG{c+cm}{ * uint32\PYGZus{}t id = 0x4; // Specify the sending Node ID.}
\PYG{c+cm}{ * etl::vector\PYGZlt{}uint8\PYGZus{}t, 8\PYGZgt{} data = \PYGZob{}0,1,2,3,4,5,6,7\PYGZcb{}; // Specify an array of data, up to 64 bytes.}
\PYG{c+cm}{ * CAN::Frame message = \PYGZob{}id, data\PYGZcb{}; // Create a CAN::Frame object.}
\PYG{c+cm}{ * canGatekeeperTask\PYGZhy{}\PYGZgt{}addToQueue(message); // Add the message to the outgoing queue.}
\PYG{c+cm}{ * @endcode}
\PYG{c+cm}{ */}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{CANGatekeeperTask}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Task}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * A freeRTOS queue to handle outgoing messages, to keep order in case tasks interrupt each other.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{n}{QueueHandle\PYGZus{}t}\PYG{+w}{ }\PYG{n}{outgoingQueue}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * The variable used to hold the queue\PYGZsq{}s data structure.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{n}{StaticQueue\PYGZus{}t}\PYG{+w}{ }\PYG{n}{outgoingQueueBuffer}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * Storage area given to freeRTOS to manage the queue items.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{outgoingQueueStorageArea}\PYG{p}{[}\PYG{n}{CAN}\PYG{o}{::}\PYG{n}{FrameQueueSize}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{CAN}\PYG{o}{::}\PYG{n}{Frame}\PYG{p}{)];}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * A freeRTOS queue to handle incoming frames part of a CAN\PYGZhy{}TP message, since they need to be parsed as a whole.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{n}{QueueHandle\PYGZus{}t}\PYG{+w}{ }\PYG{n}{incomingQueue}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * The variable used to hold the queue\PYGZsq{}s data structure.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{n}{StaticQueue\PYGZus{}t}\PYG{+w}{ }\PYG{n}{incomingQueueBuffer}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * Storage area given to freeRTOS to manage the queue items.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{incomingQueueStorageArea}\PYG{p}{[}\PYG{n}{CAN}\PYG{o}{::}\PYG{n}{FrameQueueSize}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{CAN}\PYG{o}{::}\PYG{n}{Frame}\PYG{p}{)];}

\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{TaskStackDepth}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1300}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{StackType\PYGZus{}t}\PYG{+w}{ }\PYG{n}{taskStack}\PYG{p}{[}\PYG{n}{TaskStackDepth}\PYG{p}{];}

\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{    }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{execute}\PYG{p}{();}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * The constructor calls the initialize() function of the CAN::Driver. It also initializes the FreeRTOS queues for}
\PYG{c+cm}{     * incoming/outgoing messages.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{n}{CANGatekeeperTask}\PYG{p}{();}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * Adds an CAN::Frame to the CAN Gatekeeper\PYGZsq{}s queue.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * This function was added as an extra abstraction layer to house the `xQueueSendToBack` function.}
\PYG{c+cm}{     * It can be used from anywhere in the code to get access to the CAN queue/CAN Gatekeeper task, without having to}
\PYG{c+cm}{     * know the low level details of the queue.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If the queue is full, the message is not added to the queue and an error is logged.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param message the CAN::Frame to be added in the queue of the CAN Gatekeeper task.}
\PYG{c+cm}{     * @param isISR indicating if the message is a response to another CAN Message, thus composed through an ISR}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{send}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{CAN}\PYG{o}{::}\PYG{n}{Frame}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{isISR}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{BaseType\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{p}{;}

\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{isISR}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{BaseType\PYGZus{}t}\PYG{+w}{ }\PYG{n}{taskShouldYield}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pdFALSE}\PYG{p}{;}

\PYG{+w}{            }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{xQueueSendToBackFromISR}\PYG{p}{(}\PYG{n}{outgoingQueue}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{taskShouldYield}\PYG{p}{);}

\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{taskShouldYield}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{taskYIELD}\PYG{p}{();}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{xQueueSendToBack}\PYG{p}{(}\PYG{n}{outgoingQueue}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{);}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}

\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{status}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{errQUEUE\PYGZus{}FULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{LOG\PYGZus{}ERROR}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Tried sending CAN Message while outgoing queue is full!\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * Adds a CAN::Frame to the incomingQueue.}
\PYG{c+cm}{     * If the queue is full the message is lost.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @note This function is designed to be used from within the ISR of a CAN Message Receipt. Thus, it uses}
\PYG{c+cm}{     * freeRTOS\PYGZsq{}s ISR\PYGZhy{}Specific functions.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param message The incoming CAN::Frame.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{addToIncoming}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{CAN}\PYG{o}{::}\PYG{n}{Frame}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{BaseType\PYGZus{}t}\PYG{+w}{ }\PYG{n}{taskShouldYield}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pdFALSE}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{xQueueSendToBackFromISR}\PYG{p}{(}\PYG{n}{incomingQueue}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{taskShouldYield}\PYG{p}{);}

\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{taskShouldYield}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{taskYIELD}\PYG{p}{();}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * An abstraction layer over the freeRTOS queue API to get the number of messages in the incoming queue.}
\PYG{c+cm}{     * @return The number of messages in the queue.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{getIncomingMessagesCount}\PYG{p}{()}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{uxQueueMessagesWaiting}\PYG{p}{(}\PYG{n}{incomingQueue}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * Receives a CAN::Frame from the CAN Gatekeeper\PYGZsq{}s incoming queue.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * This function was added as an extra abstraction layer to house the `xQueueReceive` function.}
\PYG{c+cm}{     * It can be used from anywhere in the code to get access to the CAN queue/CAN Gatekeeper task, without having to}
\PYG{c+cm}{     * know the low level details of the queue.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If the queue is empty, the returned message is empty.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{n}{CAN}\PYG{o}{::}\PYG{n}{Frame}\PYG{+w}{ }\PYG{n+nf}{getFromQueue}\PYG{p}{()}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{CAN}\PYG{o}{::}\PYG{n}{Frame}\PYG{+w}{ }\PYG{n}{message}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{xQueueReceive}\PYG{p}{(}\PYG{n}{incomingQueue}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{);}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{message}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * Deletes all items present in the incoming queue.}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{emptyIncomingQueue}\PYG{p}{()}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{xQueueReset}\PYG{p}{(}\PYG{n}{incomingQueue}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{createTask}\PYG{p}{()}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{xTaskCreateStatic}\PYG{p}{(}\PYG{n}{vClassTask}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{CANGatekeeperTask}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{k}{this}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{TaskName}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{CANGatekeeperTask}\PYG{o}{::}\PYG{n}{TaskStackDepth}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{this}\PYG{p}{,}
\PYG{+w}{                          }\PYG{n}{tskIDLE\PYGZus{}PRIORITY}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{this}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{taskStack}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{taskBuffer}\PYG{p}{));}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{};}

\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{::}\PYG{n}{optional}\PYG{o}{\PYGZlt{}}\PYG{n}{CANGatekeeperTask}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{canGatekeeperTask}\PYG{p}{;}
\end{Verbatim}
