\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}ifndef OBC\PYGZus{}SOFTWARE\PYGZus{}CANDRIVER\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}define OBC\PYGZus{}SOFTWARE\PYGZus{}CANDRIVER\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}cstdint\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ECSS\PYGZus{}Definitions.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}Frame.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}peripheral/mcan/plib\PYGZus{}mcan1.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}peripheral/mcan/plib\PYGZus{}mcan0.h\PYGZdq{}}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{CAN}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{     * A basic driver for the CAN Peripherals of the SAMV71 family of processors. This driver includes encoding/decoding}
\PYG{c+cm}{     * functions for the Data Length Code as well as the ID when used in normal addressing mode. There are two interrupt}
\PYG{c+cm}{     * callback functions, one for registering a transmission plus logging an error if needed, and one for passing the}
\PYG{c+cm}{     * incoming CAN::Frames to the higher level services in the application. This driver handles both peripherals,}
\PYG{c+cm}{     * while keeping only one active through a parameter for transmission, and disabling interrupts for receipt.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @note CAN Normal Addressing requires the NodeID to be at most 11 bits long.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @note There are two peripherals for the CAN Bus. The main bus is considered as MCAN1, since that is the one}
\PYG{c+cm}{     * available on the development board.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @example @code}
\PYG{c+cm}{     * uint32\PYGZus{}t id = 0x4; // Specify the sending Node ID.}
\PYG{c+cm}{     * etl::vector\PYGZlt{}uint8\PYGZus{}t, 8\PYGZgt{} data = \PYGZob{}0,1,2,3,4,5,6,7\PYGZcb{}; // Specify an array of data, up to 64 bytes.}
\PYG{c+cm}{     * CAN::Frame message = \PYGZob{}id, data\PYGZcb{}; // Create a CAN::Frame object.}
\PYG{c+cm}{     * CAN::Driver::send(message, Application::Main); // Use the included send function to send a message on the Main bus.}
\PYG{c+cm}{     * @endcode}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Driver}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Buffer that stores a message that is ready to be sent}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{n}{MCAN\PYGZus{}TX\PYGZus{}BUFFER}\PYG{+w}{ }\PYG{n}{txFifo}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Buffer that stores a received message that is to be processed.}
\PYG{c+cm}{         * In this setup, rxFifo0 is used to store TP Messages that usually span across multiple CAN::Frames}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{n}{MCAN\PYGZus{}RX\PYGZus{}BUFFER}\PYG{+w}{ }\PYG{n}{rxFifo0}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Buffer that stores a received message that is to be processed.}
\PYG{c+cm}{         * In this setup, rxFifo1 is used to store normal messages that are contained in a single CAN::Frame}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{n}{MCAN\PYGZus{}RX\PYGZus{}BUFFER}\PYG{+w}{ }\PYG{n}{rxFifo1}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * An area of memory the HAL uses to house incoming/outgoing buffers for the peripheral.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{mcan0MessageRAM}\PYG{p}{[}\PYG{n}{MCAN0\PYGZus{}MESSAGE\PYGZus{}RAM\PYGZus{}CONFIG\PYGZus{}SIZE}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}attribute\PYGZus{}\PYGZus{}}\PYG{p}{((}\PYG{n}{aligned}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{32}\PYG{p}{)))}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}attribute\PYGZus{}\PYGZus{}}\PYG{p}{((}\PYG{n}{section}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}.ram\PYGZus{}nocache\PYGZdq{}}\PYG{p}{)));}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * An area of memory the HAL uses to house incoming/outgoing buffers for the peripheral.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{mcan1MessageRAM}\PYG{p}{[}\PYG{n}{MCAN1\PYGZus{}MESSAGE\PYGZus{}RAM\PYGZus{}CONFIG\PYGZus{}SIZE}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}attribute\PYGZus{}\PYGZus{}}\PYG{p}{((}\PYG{n}{aligned}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{32}\PYG{p}{)))}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}attribute\PYGZus{}\PYGZus{}}\PYG{p}{((}\PYG{n}{section}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}.ram\PYGZus{}nocache\PYGZdq{}}\PYG{p}{)));}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Possible states for the peripheral, to be used as arguments in the callback functions.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{AppStates}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Receive}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Transmit}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{\PYGZcb{};}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * The available buses to use.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{ActiveBus}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Redundant}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mh}{0x0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Main}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mh}{0x1}
\PYG{+w}{        }\PYG{p}{\PYGZcb{};}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Sets the appropriate interrupt handlers, configures the storage area for incoming/outgoing buffers and}
\PYG{c+cm}{         * keeps only a single peripheral\PYGZsq{}s interrupts active.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{initialize}\PYG{p}{();}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Logs a successful CAN Bus transmission.}
\PYG{c+cm}{         * It is registered as a callback to be automatically called by Microchip\PYGZsq{}s HAL whenever}
\PYG{c+cm}{         * there is a message transmission on TX FIFO.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * @param context The state of the peripheral when the function is called.}
\PYG{c+cm}{         * The above parameter is a uintptr\PYGZus{}t type for compatibility with the HAL, and is casted to APPStates.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{mcan0TxFifoCallback}\PYG{p}{(}\PYG{k+kt}{uintptr\PYGZus{}t}\PYG{+w}{ }\PYG{n}{context}\PYG{p}{);}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Initiates a message receipt from the peripheral to the processor.}
\PYG{c+cm}{         * It is registered as a callback to be automatically called by Microchip\PYGZsq{}s HAL whenever}
\PYG{c+cm}{         * there is a message receipt on RX FIFO 0.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * In this setup, messages using the TP Protocol will be moved to RX FIFO 0, requiring further parsing}
\PYG{c+cm}{         * using the gatekeeper task.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * @param numberOfMessages The number of messages to be received from the peripheral}
\PYG{c+cm}{         * @param context The state of the peripheral when the function is called.}
\PYG{c+cm}{         * The above parameter is a uintptr\PYGZus{}t type for compatibility with the HAL, and is casted to APPStates.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{mcan0RxFifo0Callback}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{numberOfMessages}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uintptr\PYGZus{}t}\PYG{+w}{ }\PYG{n}{context}\PYG{p}{);}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Initiates a message receipt from the peripheral to the processor.}
\PYG{c+cm}{         * It is registered as a callback to be automatically called by Microchip\PYGZsq{}s HAL whenever}
\PYG{c+cm}{         * there is a message receipt on RX FIFO 1.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * In this setup, all received messages are contained in a single frame and will immediately be processed}
\PYG{c+cm}{         * in this callback.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * @param numberOfMessages The number of messages to be received from the peripheral}
\PYG{c+cm}{         * @param context The state of the peripheral when the function is called.}
\PYG{c+cm}{         * The above parameter is a uintptr\PYGZus{}t type for compatibility with the HAL, and is casted to APPStates.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{mcan0RxFifo1Callback}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{numberOfMessages}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uintptr\PYGZus{}t}\PYG{+w}{ }\PYG{n}{context}\PYG{p}{);}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Logs a successful CAN Bus transmission.}
\PYG{c+cm}{         * It is registered as a callback to be automatically called by Microchip\PYGZsq{}s HAL whenever}
\PYG{c+cm}{         * there is a message transmission on TX FIFO.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * @param context The state of the peripheral when the function is called.}
\PYG{c+cm}{         * The above parameter is a uintptr\PYGZus{}t type for compatibility with the HAL, and is casted to APPStates.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{mcan1TxFifoCallback}\PYG{p}{(}\PYG{k+kt}{uintptr\PYGZus{}t}\PYG{+w}{ }\PYG{n}{context}\PYG{p}{);}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Initiates a message receipt from the peripheral to the processor.}
\PYG{c+cm}{         * It is registered as a callback to be automatically called by Microchip\PYGZsq{}s HAL whenever}
\PYG{c+cm}{         * there is a message receipt on RX FIFO 0.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * In this setup, messages using the TP Protocol will be moved to RX FIFO 0, requiring further parsing}
\PYG{c+cm}{         * using the gatekeeper task.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * @param numberOfMessages The number of messages to be received from the peripheral}
\PYG{c+cm}{         * @param context The state of the peripheral when the function is called.}
\PYG{c+cm}{         * The above parameter is a uintptr\PYGZus{}t type for compatibility with the HAL, and is casted to APPStates.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{mcan1RxFifo0Callback}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{numberOfMessages}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uintptr\PYGZus{}t}\PYG{+w}{ }\PYG{n}{context}\PYG{p}{);}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Initiates a message receipt from the peripheral to the processor.}
\PYG{c+cm}{         * It is registered as a callback to be automatically called by Microchip\PYGZsq{}s HAL whenever}
\PYG{c+cm}{         * there is a message receipt on RX FIFO 1.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * In this setup, all received messages are contained in a single frame and will immediately be processed}
\PYG{c+cm}{         * in this callback.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * @param numberOfMessages The number of messages to be received from the peripheral}
\PYG{c+cm}{         * @param context The state of the peripheral when the function is called.}
\PYG{c+cm}{         * The above parameter is a uintptr\PYGZus{}t type for compatibility with the HAL, and is casted to APPStates.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{mcan1RxFifo1Callback}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{numberOfMessages}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uintptr\PYGZus{}t}\PYG{+w}{ }\PYG{n}{context}\PYG{p}{);}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Logs messages that are in the Rx buffer}
\PYG{c+cm}{         * @param rxBuf The RX Buffer that the messages are stored}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{logMessage}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{MCAN\PYGZus{}RX\PYGZus{}BUFFER}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{rxBuf}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ActiveBus}\PYG{+w}{ }\PYG{n}{incomingBus}\PYG{p}{);}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Decodes the data length code to get the largest expected size of the message.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * @param dlc The data length code}
\PYG{c+cm}{         * @return The length of the message in bytes}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{convertDlcToLength}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{dlc}\PYG{p}{);}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Encodes the length of the message body to the smallest data length code that it fits in.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * @param length The length of the message in bytes}
\PYG{c+cm}{         * @return The data length code}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{convertLengthToDLC}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{length}\PYG{p}{);}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Transforms a frame ID to conform to the CAN Standard.}
\PYG{c+cm}{         * The implementation shifts non\PYGZhy{}extended IDs by 18 bits to ease debugging with example projects.}
\PYG{c+cm}{         * @param id The ID as specified in the standard.}
\PYG{c+cm}{         * @return The ID that\PYGZsq{}s sent over the network.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * @note All IDs should be at most 11 bits long as the non\PYGZhy{}extended ID scheme is used. The function gets/returns}
\PYG{c+cm}{         * a 32\PYGZhy{}bit ID to accomodate the shift.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{writeId}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{id}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{id}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{18}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Transforms the ID from the CAN Standard to match a frame ID.}
\PYG{c+cm}{         * @param id The ID that was received from the network.}
\PYG{c+cm}{         * @return The ID as specified in the standard.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * @note All IDs should be at most 11 bits long as the non\PYGZhy{}extended ID scheme is used. The function gets/returns}
\PYG{c+cm}{         * a 32\PYGZhy{}bit ID to accomodate the shift.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{readId}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{id}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{id}\PYG{+w}{ }\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{18}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Immediately ends a CAN Message}
\PYG{c+cm}{         * @param message The message to be sent.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{send}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{CAN}\PYG{o}{::}\PYG{n}{Frame}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{);}

\PYG{+w}{        }\PYG{c+cm}{/**}
\PYG{c+cm}{         * Converts an MCAN\PYGZus{}RX\PYGZus{}BUFFER object into a CAN::Frame.}
\PYG{c+cm}{         * @param rxBuffer The incoming buffer.}
\PYG{c+cm}{         * @return A CAN::Frame.}
\PYG{c+cm}{         */}
\PYG{+w}{        }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{CAN}\PYG{o}{::}\PYG{n}{Frame}\PYG{+w}{ }\PYG{n+nf}{getFrame}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{MCAN\PYGZus{}RX\PYGZus{}BUFFER}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{rxBuffer}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{};}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}endif }\PYG{c+c1}{//OBC\PYGZus{}SOFTWARE\PYGZus{}CANDRIVER\PYGZus{}H}
\end{Verbatim}
